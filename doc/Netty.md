[TOC]
# pre:线程模型
数据如何读取？ 读取之后的数据编解码在哪个线程执行？编解码后的数据如何处理？线程模型的不同，对性能的影响也非常显著。

1. **事件驱动模型**      
    1. **事件驱动模型的思路**：
        - 轮询方式：线程不断轮询事件有没有发生变化，发生变化则调用相关事件处理器。
        - 事件驱动方式：事件发生改变，主线程把事件放入事件队列，其他线程不断循环消费事件队列中的事件，消费事件时，调用相应的事件处理器，因此事件驱动方式也称为消息通知方式，其设计模式类似于观察者模式。        

    2. **事件驱动模型图解**：     
    [link](/images/event_driven.png)            
    3. **四个基本组件**     
        -  事件队列（event queue）：接收事件的入口，存储待处理的事件
        -  分发器(event mediator): 将不同的事件分发到相应的事件通道中。
        -  事件通道(event channel)：分发器与处理器之间的联系桥梁
        -  事件处理器(event processor)：实现业务逻辑，处理完业务发出事件，触发下一步操作。
2. **Reactor线程模型**  
Reactor 是反应堆的意思，Reactor 模型是指通过一个或多个输入同时传递给服务处理器的服务请求的事件驱动处理模式。    
服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I/O 多了复用统一监听事件，收到事件后分发(Dispatch 给某进程)，是编写高性能网络服务器的必备技术之一。

    1. **Reactor 模型中组成：**
    - Reactor，Reactor 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 IO 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人。
    - Handlers，处理程序执行 I/O 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor 通过调度适当的处理程序来响应 I/O 事件，处理程序执行非阻塞操作。
    2. **Reactor线程模型图解**  
        [link](/images/Reactor.png)   
    3. **Reactor模型的三个变种**
        - 单 Reactor 单线程。
        - 单 Reactor 多线程。
        - 主从 Reactor 多线程。

# 一、Netty简介   
Netty是一个异步事件驱动的网络应用程序组件，可用于开发可维护性的高性能协议服务器和客户端。
高性能之处主要来自于其 I/O 模型和线程处理模型，前者决定如何收发数据，后者决定如何处理数据。    
# 二、 传统IO与NIO读写数据的方式
传统IO是基于字节流与字符流，以流式的方式顺序地从一个流中读取或写入一个或多个字节，不能随意改变读取指针的位置。  
读写数据：Stream <——> Stream

---
NIO 抛弃了传统的IO流，而是引入了Channel和Buffer的概念，NIO只能从Channel中读取数据到Buffer中或将数据从Buffer中写入到Channel  
读数据: Channel ——> Buffer         
写数据: Channel <—— Buffer
# 二、JDK原生NIO缺点
1. NIO 的类库和 API 繁杂，使用麻烦。你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等。 
2. 需要具备其他的额外技能做铺垫。例如熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，你必须对多线程和网路编程非常熟悉，才能编写出高质量的 NIO 程序   。
3. 可靠性能力补齐，开发工作量和难度都非常大。例如客户端面临断连重连、网络闪断、半包读写、缓存失败、网络拥塞和异常处理等等。 4.  NIO 编程的特点是功能开发相对容易，但是可靠性能力补齐工作量和难度都非常大。
5. JDK NIO 的 Bug。例如臭名昭著的 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。 官方声称在 JDK 1.6 版本的 update 18 修复了该问题，但是直到 JDK 1.7 版本该问题仍旧存在，只不过该 Bug 发生概率降低了一些而已，它并没有被根本解决

# 三、 Netty的特点
1. 适用于各种传输类型的统一 API 阻塞和非阻塞Socket；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型 - 单线程，一个或多个线程池；真正的无连接数据报套接字支持（自 3.1 起）
2. 使用方便，详细记录的 Javadoc，用户指南和示例；没有其他依赖项
3. 社区活跃，不断更新，社区活跃，版本迭代周期短，发现的 Bug 可以被及时修复，同时，更多的新功能会被加入。

# 四、IO
IO分为三类：阻塞型IO(BIO)，非阻塞型IO（NIO），异步IO(AIO)
1. **传统阻塞型IO（BIO）**
- **模型**  
[link](/image/BIO.png)
- **特点** 
    1. 每个请求都需要独立的线程完成数据读取，业务的处理
    2. 当并发量较大时，需要创建大量的线程来处理系统连接，系统资源占用大。
    3. 连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在Read的操作上，造成线程资源浪费。
2. **IO复用模型**   
[link](、image/IO_Reuse.png)    
在 I/O 复用模型中，会用到 Select，这个函数也会使进程阻塞，但是和阻塞 I/O 所不同的是这两个函数可以同时阻塞多个 I/O 操作。      
而且可以同时对多个读操作，多个写操作的 I/O 函数进行检测，直到有数据可读或可写时，才真正调用 I/O 操作函数。
3. **非阻塞型IO（NIO）**
- **模型**
[link](/image/NIO.png)  
- **特点**  
Netty的IO线程NioEventLoop由于聚合了多路复用器Selector,可以同时并发处理成百上千个客户端连接。当线程从某客户端Socket，通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。线程通常将非阻塞 IO 的空闲时间用于在其他通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道。    由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 I/O 阻塞导致的线程挂起。一个 I/O 线程可以并发处理 N 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 I/O 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。


# 五、使用场景
1. 互联网行业。在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。 典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。
2. 游戏行业。无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈。 非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过 Netty 进行高性能的通信。
3. 大数据领域。经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨节点通信，它的 Netty Service 基于 Netty 框架二次封装实现
